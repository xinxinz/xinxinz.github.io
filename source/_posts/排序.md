---
title: 常见排序算法
date: 2019-01-20
---

### 排序


#### 冒泡排序（Bubble Sort）
它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。


##### 算法描述
1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。


##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)


##### 代码实现
```php
function bubbleSort($arr)
{
	$count = count($arr);
	for ($i=0; $i < $count - 1; $i++) { 
		$flag = false;
		for ($j=0; $j < $count - 1 - $i; $j++) { 
			if ($arr[$j] > $arr[$j+1]) {
				$temp = $arr[$j];
				$arr[$j] = $arr[$j+1];
				$arr[$j+1] = $temp;
				$flag = true;
			}
		}
		if(!$flag){ // 优化:是否交换标志, 没有交换即已经排序完成，没有必要再循环了
			break;
		}
	}
	return $arr;
}
```

##### 算法分析
| 时间复杂度(平均)|时间复杂度(最差)|时间复杂度(最好)| 空间复杂度 |
| :--: | :--: | :--: | :--:  | 
| $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(１)$ |



#### 选择排序（Selection Sort）
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

##### 代码实现
```php
function selectionSort($arr)
{
	$length = count($arr);
	for ($i=0; $i < $length - 1; $i++) { 
		$base = $i;
		for ($j = $i + 1; $j < $length; $j++) {　// 注: 第二层交换的起止 
			if ($arr[$base] > $arr[$j]) {
				$base = $j;
			}
		}
		if ($base != $i) {　 
			$temp = $arr[$i];
			$arr[$i] = $arr[$base];
			$arr[$base] = $temp;
		}
	}
	return $arr;
}
```

##### 算法分析
| 时间复杂度(平均)|时间复杂度(最差)|时间复杂度(最好)| 空间复杂度 |
| :--: | :--: | :--: | :--:  | 
| $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(１)$ |


#### 插入排序（Insertion Sort）
在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序

##### 算法描述
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

##### 代码实现
```php
function insertionSort($arr)
{
	$length = count($arr);
	for ($i = 1; $i <= $length - 1; $i++) { 
		$val = $arr[$i];
		$index = $i - 1;
		while ($index >= 0 && $val < $arr[$index] ) {
			$arr[$index + 1] = $arr[$index];
			$index--;
		}
		if ($index + 1 != $i) {
			$arr[$index + 1] = $val;
		}
	}
	return $arr;
}
```

##### 算法分析
| 时间复杂度(平均)|时间复杂度(最差)|时间复杂度(最好)| 空间复杂度 |
| :--: | :--: | :--: | :--:  | 
| $O(n^2)$ | $O(n^2)$ | $O(n)$ | $O(１)$ |

#### 希尔排序（Shell Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)

##### 代码实现
```php

```

##### 算法分析

#### 归并排序（Merge Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif)

##### 代码实现
```php

```

##### 算法分析

#### 快速排序（Quick Sort）

##### 算法描述
1. 先从数列中取出一个数作为key值；
2. 将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；
3. 对左右两个小数列重复第二步，直至各区间只有1个数。

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

##### 代码实现
```php
// 从大到小排序
function quickSort(&$arr, $left, $right)
{
	if ($left > $right) return;
	$i = $left; $j = $right;
	$middle = $arr[$left];
	while ($i < $j) {
		// 必须先从右边开始查找　
		// 右边的数字都要比基准值大，所以要循环遍历直至找到比基准值小的值，查找结束
		while ($arr[$j] >= $middle && $i < $j) {
		// while ($arr[$j] <= $middle && $i < $j)　从大到小
	 		$j--;
		}
		while($arr[$i] <= $middle && $i < $j){
		// while($arr[$i] >= $middle && $i < $j) 从大到小
			$i++;
		}
		if ($i < $j) {
			$temp = $arr[$i];
			$arr[$i] = $arr[$j];
			$arr[$j] = $temp;
		}
	}
	$arr[$left] = $arr[$i];
	$arr[$i] = $middle;
	quickSort($arr, $left, $i-1);
	quickSort($arr, $i+1, $right);
}
```

##### 算法分析

#### 堆排序（Heap Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif)

##### 代码实现
```php

```

##### 算法分析

#### 计数排序（Counting Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif)

##### 代码实现
```php

```

##### 算法分析

#### 桶排序（Bucket Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png)

##### 代码实现
```php

```

##### 算法分析

#### 基数排序（Radix Sort）

##### 算法描述

##### 动图演示
![enter image description here](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif)

##### 代码实现
```php

```

##### 算法分析


参考　https://www.cnblogs.com/onepixel/articles/7674659.html
http://www.runoob.com/w3cnote/sort-algorithm-summary.html

```

#include <stdio.h>

void show(int *arr){
	printf("\n");
	int i = 0;
	for (i = 0; i < 10; ++i)
	{
	printf("%d ", arr[i]);
	}
	printf("\n");
}
void change(int *arr, int i, int j){
	
	int tmp = arr[i];
	arr[i] = arr[j];
	arr[j] = tmp;
}
void k_sort(int *arr, int left, int right){
	if(left > right) return;
	int temp = arr[left];
	int i = left, j=right;
	while(i != j){
		while(arr[j] >= temp && i < j){
			j--;
		}
		while(arr[i] <= temp && i < j){
			i++;		
		}
		if(j > i){
			change(arr, i, j);
		}
	}
	arr[left] = arr[i];
	arr[i] = temp;
	k_sort(arr, left, i-1);
	k_sort(arr, i+1, right);
}
int main(){
	int arr[10] = {3,44,38,5,47,15,36,26,27,2,46,4,9,50,48,1};
	show(arr);
	k_sort(arr, 0, 9);
	show(arr);
}
```
